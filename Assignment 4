1.

#include <iostream>
using namespace std;
//1 2 3 4 5 6 7
class queue{
  
  public:
  int front;
  int rear;
  int len;
  int* q;
  queue(int size){
      len=size;
      q=new int[len];
      front=-1;
      rear=-1;
  }
  bool isempty(){
      if(front== -1 && rear==-1){
          return true;
      }
      else
      return false;
  }
  bool isfull(){
      if(rear== (len-1)){
          return true;
      }
      else
      return false;
  }
  void enqueue(int val){
      if(isfull()){
          cout<<"Q is full"<<endl;
      }
      else{
          if(isempty()){
              front=0;
          }
          rear++;
          q[rear]= val;
      }
  }
  void dequeue(){
      if(isempty()){
          cout<<"Q is empty"<<endl;
      }
else if(front==rear){
          front=rear=-1;
      }
      else{
         front++;
      }
  }
  void display(){
      for(int i=front;i<=rear;i++){
          cout<<q[i]<<"  ";
      }
      cout<<endl;
  }
};
int main() {
    queue q1(10);
    q1.enqueue(1);
    q1.enqueue(2);
    q1.enqueue(3);
    q1.enqueue(4);
    q1.enqueue(5);
    q1.enqueue(6);
    q1.enqueue(7);
    q1.enqueue(8);
    q1.enqueue(9);
    q1.display();
    q1.dequeue();
    q1.dequeue();
    q1.dequeue();
    q1.dequeue();
    q1.display();
    

    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.  


#include <iostream>
using namespace std;
//1 2 3 4 5 6 7
class queue{
  
  public:
  int front;
  int rear;
  int len;
  int* q;
  queue(int size){
      len=size;
      q=new int[len];
      front=-1;
      rear=-1;
  }
  bool isempty(){
      if(front== -1 && rear==-1){
          return true;
      }
      else
      return false;
  }
  bool isfull(){
      if(front==(rear+1)%len){
          return true;
      }
      else
      return false;
  }
  void enqueue(int val){
      if(isfull()){
          cout<<"Q is full"<<endl;
      }
      else{
          if(isempty()){
              front=0;
          }
          rear=(rear+1)%len;
          q[rear]= val;
      }
  }
  void dequeue(){
      if(isempty()){
          cout<<"Q is empty"<<endl;
      }
      else if(front==rear){
          front=rear=-1;
      }
      else{
         front=(front+1)%len;
      }
  }
  void display(){
      int i=front ;
      while(1){
          cout<<q[i]<<"  ";
          if(i==rear){
              break;
          }
          i=(i+1)%len;
      }
      cout<<endl;
  }
};
int main() {
    queue q1(10);
    q1.enqueue(1);
    q1.enqueue(2);
    q1.enqueue(3);
    q1.enqueue(4);
    q1.enqueue(5);
    q1.enqueue(6);
    q1.enqueue(7);
    q1.enqueue(8);
    q1.enqueue(9);
    q1.display();
    q1.dequeue();
    q1.dequeue();
    q1.dequeue();
    q1.dequeue();
    q1.display();
    q1.enqueue(5);
    q1.enqueue(6);
    q1.enqueue(7);
    q1.enqueue(8);
    q1.display();
    

    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3.   Write a program interleave the first half of the queue with second half.
     Sample I/P: 4 7 11 20 5 9 Sample O/P: 4 20 7 5 11 9


#include <iostream>
#include <queue>
using namespace std;
int main() {
    queue<int>q;
    queue<int>temp;
    q.push(4);
    q.push(7);
    q.push(11);
    q.push(20);
    q.push(5);
    q.push(9);
    int originalSize = q.size();
    int i = 0;
    while (i < originalSize / 2) {
    temp.push(q.front());
    q.pop();
    i++;
    }
    i=0;
     while(i < originalSize / 2){
         q.push(temp.front());
         temp.pop();
         q.push(q.front());
         q.pop();
         i++;
     }
    while (!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
   
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------
4.  C++ program for a Queue based approach 
    to find first non-repeating character


#include <bits/stdc++.h>
using namespace std;
const int MAX_CHAR = 26;
void firstnonrepeating(char str[])
{
    queue<char> q;
    int charCount[MAX_CHAR] = { 0 };
    for (int i = 0; str[i]; i++) {
       // push each character in queue
        q.push(str[i]);
        // increment the frequency count
        charCount[str[i] - 'a']++;
        // check for the non repeating character
        while (!q.empty()) {
            if (charCount[q.front() - 'a'] > 1)
                q.pop();
            else {
                cout << q.front() << " ";
                break;
            }
        }
        if (q.empty())
            cout << -1 << " ";
    }
    cout << endl;
}

int main()
{
    char str[] = "abcdefgbcdefag";
    firstnonrepeating(str);
    return 0;
}
-------------------------------------------------------------------------------------------------------------------------------
5) Write a program to implement a stack using (a) Two queues and (b) One Queue.
(b)
#include <iostream>
#include <queue>
using namespace std;
class stack{
    queue<int> q;
    public:
    bool isEmpty(){
        return q.empty();
    }
    void spush(int a){
        q.push(a);
    }
    void spop(){
        int num= q.back();
        while(q.front()!=num){
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    void display(){
        while(!q.empty()){
            cout<<q.front()<<"  ";
            q.pop();
        }
    }
};
//1 22 33 44 55
int main()
{
   stack s;
   s.spush(2);
   s.spush(22);
   s.spush(33);
   s.spush(44);
   s.spush(267);
   s.spush(208);
   s.spush(222);
   s.spop();
   s.display();
    return 0;
}
                           ORRR

#include <iostream>
#include <queue>
using namespace std;
class stack{
    queue<int> q;
    public:
    bool isEmpty(){
        return q.empty();
    }
    void spush(int a){
        int size = q.size();
        q.push(a);
        for(int i=0; i<size; i++){
            q.push(q.front());
            q.pop();
        }
    }
    void spop(){
        q.pop();
    }
    int stop(){
        return q.front();
    }
};
//1 22 33 44 55
int main()
{
   stack s;
   s.spush(2);
   s.spush(22);
   s.spush(33);
   s.spush(44);
   s.spush(267);
   cout<<s.stop() << " Top" << endl;
   s.spush(208);
   s.spush(222);
   s.spop();
   cout <<s.stop()<<" Top"<< endl;
   
    return 0;
}

(a)
#include <iostream>
#include <queue>
using namespace std;

class StackTwoQueues {
    queue<int> q1, q2;

public:
    void push(int x) {
        q2.push(x);
         while (!q1.empty()) {
            
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1, q2);
    }

    void pop() {
        if (q1.empty()) {
            cout << "Stack is empty\n";
            return;
        }
        q1.pop();
    }

    int top() {
        if (q1.empty()) {
            cout << "Stack is empty\n";
            return -1;
        }
        return q1.front();
    }

    bool empty() {
        return q1.empty();
    }
};

int main() {
    StackTwoQueues s;
    s.push(10);
    s.push(20);
    s.push(30);
    s.top();
    s.pop();
    s.top();


    return 0;
}
