ASSIGNMENT 6

#include <iostream>
using namespace std;

class polygon{
    protected:
    int width;
    int height;
    public:
    polygon(){
        width=0;
        height=0;
    }
    polygon(int w,int h){
        width=w;
        height=h;
    }
    virtual void calculate_area(){}
};
class rectangle:public polygon{
    public:
    rectangle(int he,int wi):polygon(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<height*width<<endl;
    }
};
class triangle:public polygon{
    public:
    triangle(int he,int wi):polygon(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<0.5*height*width<<endl;
    }
};

int main() {
    rectangle r(6,7);
    polygon *ptr=&r;
    ptr->calculate_area();
    triangle t(4,5);
    ptr=&t;
    ptr->calculate_area();
    return 0;
}

=============================================================================================================================================

#include <iostream>
using namespace std;

class shape{
    protected:
    int width;
    int height;
    public:
    shape(){
        width=0;
        height=0;
    }
    shape(int w,int h){
        width=w;
        height=h;
    }
    virtual void calculate_area(){
        
    }
    virtual void display(){
        
    }
};
class rectangle:public shape{
    public:
    rectangle(int he,int wi):shape(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<height*width<<endl;
    }
    void display(){
        cout<<"This a rectangle"<<endl;
    }
};
class triangle:public shape{
    public:
    triangle(int he,int wi):shape(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<0.5*height*width<<endl;
    }
    void display(){
        cout<<"This a triangle"<<endl;
    }
};
class circle:public shape{
    int rad;
    public:
    circle(int r){
        rad=r;
    };
    void calculate_area(){
        cout<<"Area is "<<(3.141592654)*rad*rad<<endl;
    }
    void display(){
        cout<<"This a circle"<<endl;
    }
};
int main() {
    rectangle r(6,7);
    shape *ptr=&r;
    ptr->calculate_area();
    triangle t(4,5);
    ptr=&t;
    ptr->calculate_area();
    circle c(7);
    ptr=&c;
    ptr->calculate_area();
    return 0;
}

==========================================================================================================================================================================================

#include <iostream>
#include <string>
using namespace std;

// Abstract base class
class Student {
protected:
    string name;
    int rollNo;

public:
    // Constructor
    Student(string n, int r) : name(n), rollNo(r) {}

    // Pure virtual function → makes this class abstract
    virtual void showDetails() = 0;

    // Virtual destructor (important for proper cleanup)
    virtual ~Student() {}
};

// Derived class: Engineering
class Engineering : public Student {
    string branch;
public:
    Engineering(string n, int r, string b)
        : Student(n, r), branch(b) {}

    void showDetails() override {
        cout << "Engineering Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nBranch: " << branch << "\n\n";
    }
};

// Derived class: Medicine
class Medicine : public Student {
    string specialization;
public:
    Medicine(string n, int r, string s)
        : Student(n, r), specialization(s) {}

    void showDetails() override {
        cout << "Medicine Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nSpecialization: " << specialization << "\n\n";
    }
};

// Derived class: Science
class Science : public Student {
    string major;
public:
    Science(string n, int r, string m)
        : Student(n, r), major(m) {}

    void showDetails() override {
        cout << "Science Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nMajor: " << major << "\n\n";
    }
};

// Main function
int main() {
    // Create objects of derived classes
    Engineering e1("Alice", 101, "Computer Engineering");
    Medicine m1("Bob", 102, "Cardiology");
    Science s1("Charlie", 103, "Physics");

    // Array of base class pointers
    Student* students[3];

    // Assign derived objects to base class pointers
    students[0] = &e1;
    students[1] = &m1;
    students[2] = &s1;

    // Process them using polymorphism
    for (int i = 0; i < 3; ++i) {
        students[i]->showDetails();
    }

    return 0;
}


===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
                                                                                                 ASSIGNMENT 7
===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
1.

#include <iostream>
using namespace std;

class Time{
    protected:
    int h,m,s;
     public:
    Time(){
        h=0;
        m=0;
        s=0;
    }
    Time(int hour,int min, int sec){
        h=hour;
        m=min;
        s=sec;
    }
   
    void show(){
        cout<<h<<" hours "<<m<<" minutes "<<s<<" seconds ";
    }
    Time operator+(Time t){
        Time res;
        res.h=t.h+h;
        res.m=t.m+m;
        res.s=t.s+s;
        return res;
    }
    
};
int main(){
    Time t1(5,15,34),t2(9,53,58),t3;
    t3=t1+t2;
    t3.show();
    return 0;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.

#include <iostream>
#include <string>
using namespace std;

class STRING{
    protected:
    string s; 
     public:
    STRING(){
        s="";
    }
    STRING(string str){
        s=str;
    }
   
    void show(){
        cout<<s<<endl;
    }
    STRING operator+(STRING t){
        STRING res;
        res=s+t.s;
       return res;
    }
    bool operator==(STRING t){
        if(s==t.s)
        return true;
        else 
        return false;
    }
    
};
int main(){
    STRING s1("roop"),s2("neet"),s3("roop"),s4;
    s4=s1+s2;
    s4.show();
    cout<<(s1==s2)<<endl;
    cout<<(s1==s3)<<endl;
    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.
#include <iostream>
using namespace std;

class matrix {
protected:
    int rows, cols;
    int mat[10][10];

public:
    matrix(int r = 0, int c = 0) {
        rows = r;
        cols = c;
    }

    void input() {
        cout << "Enter elements:" << endl;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cin >> mat[i][j];
            }
        }
    }

    void display() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cout << mat[i][j] << " ";
            }
            cout << endl;
        }
    }

    friend matrix operator*(const matrix &m1, const matrix &m2);
};

matrix operator*(const matrix &m1, const matrix &m2) {
    // Check if multiplication is possible
    if (m1.cols != m2.rows) {
        cout << "Matrix multiplication not possible!" << endl;
        return matrix();
    }

    matrix res(m1.rows, m2.cols);

    for (int i = 0; i < m1.rows; i++) {
        for (int j = 0; j < m2.cols; j++) {
            res.mat[i][j] = 0;
            for (int k = 0; k < m1.cols; k++) {
                res.mat[i][j] += m1.mat[i][k] * m2.mat[k][j];
            }
        }
    }

    return res;
}

int main() {
    matrix m1(3, 3), m2(3, 3);

    cout << "Enter matrix 1:" << endl;
    m1.input();
    m1.display();

    cout << "Enter matrix 2:" << endl;
    m2.input();
    m2.display();

    matrix m3 = m1 * m2;

    cout << "Result matrix:" << endl;
    m3.display();

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7. 

#include <iostream>
using namespace std;

class test{
    float value;
    public:
    test(float x){
        value=x;
    }
    void display(){
        cout<<"Value is "<<value<<endl;
    }
};
int main() {
    float a=8.6;
    test obj=a;
    obj.display();
    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8.

#include <iostream>
using namespace std;

class test{
    float value;
    public:
    test(float x){
        value=x;
    }
    void display(){
        cout<<"Value is "<<value<<endl;
    }
    operator float(){
        return value;
    }
};
int main() {
    test t1(45.4);
    float x;
    x=t1;
    cout<<"Float value = "<<x<<endl;
    return 0;
}


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9.#include <iostream>
#include <cmath>
using namespace std;

class Cartesian {
private:
    float x, y;

public:
    Cartesian(float a = 0, float b = 0) {
        x = a;
        y = b;
    }

    void show() {
        cout << "Cartesian Coordinates: (" << x << ", " << y << ")" << endl;
    }
};

class Polar {
private:
    float r, theta;   // theta in radians

public:
    Polar(float radius = 0, float angle = 0) {
        r = radius;
        theta = angle;
    }

    // UDT (Polar) → UDT (Cartesian) conversion
    operator Cartesian() {
        float x = r * cos(theta); 
        float y = r * sin(theta);
        return Cartesian(x, y);
    }
};

int main() {
    Polar p(10, 5);        // r = 10, θ = 5 radians
    Cartesian c = p;       // calls conversion operator
    c.show();

    return 0;
}
