===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
                                                                                        ASSIGNMENT 5
===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
1.
#include <iostream>
using namespace std;

class Alpha {
private:
    int a;

public:
    Alpha(int x) : a(x) {
        cout << "Alpha Constructor, a = " << a << endl;
    }

    ~Alpha() {
        cout << "Alpha Destructor\n";
    }
};

class Beta {
private:
    int b;

public:
    Beta(int y) : b(y) {
        cout << "Beta Constructor, b = " << b << endl;
    }

    ~Beta() {
        cout << "Beta Destructor\n";
    }
};

class Gamma : public Alpha, public Beta {
private:
    int c;

public:
    Gamma(int x, int y, int z) : Alpha(x), Beta(y), c(z) {
        cout << "Gamma Constructor, c = " << c << endl;
    }

    ~Gamma() {
        cout << "Gamma Destructor\n";
    }
};

int main() {
    Gamma g(10, 20, 30);

    return 0;
}


===============================================================================================================================================================================================================
2.
#include <iostream>
#include <cstring>
using namespace std;

class X {
protected:
    char str1[50];

public:
    X(const char* s) {
        strcpy(str1, s);
        cout << "X Constructor Called\n";
    }

    void showX() {
        cout << "String in X: " << str1 << endl;
    }

    ~X() {
        cout << "X Destructor Called\n";
    }
};

class Y {
protected:
    char str2[50];

public:
    Y(const char* s) {
        strcpy(str2, s);
        cout << "Y Constructor Called\n";
    }

    void showY() {
        cout << "String in Y: " << str2 << endl;
    }

    ~Y() {
        cout << "Y Destructor Called\n";
    }
};

// Z inherits from X and Y
class Z : public X, public Y {
private:
    char str3[100];

public:
    Z(const char* s1, const char* s2) : X(s1), Y(s2) {
        strcpy(str3, str1);
        strcat(str3, str2);
        cout << "Z Constructor Called\n";
    }

    void showZ() {
        cout << "Concatenated String in Z: " << str3 << endl;
    }

    ~Z() {
        cout << "Z Destructor Called\n";
    }
};

int main() {
    Z obj("Hello ", "World!");

    obj.showX();
    obj.showY();
    obj.showZ();

    return 0;
}


===============================================================================================================================================================================================================

3.
#include <iostream>
using namespace std;

/*
   Diamond Structure:
          Base
         /    \
     (virtual) (virtual)
       B1        B2
         \      /
           \   /
             C
*/

class Base {
protected:
    int x;
public:
    Base() {
        cout << "Enter value for Base: ";
        cin >> x;
    }
    void showBase() {
        cout << "Base = " << x << endl;
    }
};

class B1 : virtual public Base {
public:
    B1() {
        cout << "Constructor of B1\n";
    }
};

class B2 : virtual public Base {
public:
    B2() {
        cout << "Constructor of B2\n";
    }
};

class C : public B1, public B2 {
    int y;
public:
    C() {
        cout << "Enter value for C: ";
        cin >> y;
    }
    void show() {
        showBase();   // Only one copy due to virtual inheritance
        cout << "C = " << y << endl;
    }
};

int main() {
    C obj;
    cout << "\nDisplaying values:\n";
    obj.show();
    return 0;
}

===============================================================================================================================================================================================================
4.
#include <iostream>
#include <string>
using namespace std;

// -------------------------
// Abstract Base Class
// -------------------------
class Student {
protected:
    string name;
    int roll;

public:
    Student(string n, int r) : name(n), roll(r) {}

    // Pure virtual function (makes class abstract)
    virtual void display() = 0;

    // Virtual destructor
    virtual ~Student() {}
};

// -------------------------
// Derived Class: Science
// -------------------------
class Science : public Student {
private:
    int practicalMarks;

public:
    Science(string n, int r, int pm) : Student(n, r), practicalMarks(pm) {}

    void display() override {
        cout << "Science Student\n";
        cout << "Name: " << name << "\nRoll: " << roll 
             << "\nPractical Marks: " << practicalMarks << "\n\n";
    }
};

// -------------------------
// Derived Class: Art
// -------------------------
class Art : public Student {
private:
    int drawingMarks;

public:
    Art(string n, int r, int dm) : Student(n, r), drawingMarks(dm) {}

    void display() override {
        cout << "Art Student\n";
        cout << "Name: " << name << "\nRoll: " << roll 
             << "\nDrawing Marks: " << drawingMarks << "\n\n";
    }
};

// -------------------------
// Derived Class: Commerce
// -------------------------
class Commerce : public Student {
private:
    int accountMarks;

public:
    Commerce(string n, int r, int am) : Student(n, r), accountMarks(am) {}

    void display() override {
        cout << "Commerce Student\n";
        cout << "Name: " << name << "\nRoll: " << roll 
             << "\nAccount Marks: " << accountMarks << "\n\n";
    }
};

// -------------------------
// Main Function
// -------------------------
int main() {

    // Array of base class pointers
    Student* s[3];

    // Creating objects of derived classes
    s[0] = new Science("Riya", 101, 85);
    s[1] = new Art("Kabir", 102, 90);
    s[2] = new Commerce("Aman", 103, 88);

    // Processing using base class pointer array
    for (int i = 0; i < 3; i++) {
        s[i]->display();   // Polymorphism
    }

    // Freeing memory
    for (int i = 0; i < 3; i++) {
        delete s[i];
    }

    return 0;
}

===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
                                                                                        ASSIGNMENT 6
===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
1.
#include <iostream>
using namespace std;

class polygon{
    protected:
    int width;
    int height;
    public:
    polygon(){
        width=0;
        height=0;
    }
    polygon(int w,int h){
        width=w;
        height=h;
    }
    virtual void calculate_area(){}
};
class rectangle:public polygon{
    public:
    rectangle(int he,int wi):polygon(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<height*width<<endl;
    }
};
class triangle:public polygon{
    public:
    triangle(int he,int wi):polygon(he,wi){};
    void calculate_area(){
        cout<<"Area is "<<0.5*height*width<<endl;
    }
};

int main() {
    rectangle r(6,7);
    polygon *ptr=&r;
    ptr->calculate_area();
    triangle t(4,5);
    ptr=&t;
    ptr->calculate_area();
    return 0;
}

=============================================================================================================================================
2.
#include <iostream>
using namespace std;

class shape {
protected:
    int width;
    int height;

public:
    shape() : width(0), height(0) {}

    shape(int w, int h) : width(w), height(h) {}

    virtual void calculate_area() = 0;

    virtual void display() {
        cout << "This is a shape\n";
    }

    virtual ~shape() {}   // Good practice
};

class rectangle : public shape {
public:
    rectangle(int w, int h) : shape(w, h) {}

    void calculate_area() override {
        cout << "Area of Rectangle = " << width * height << endl;
    }

    void display() override {
        cout << "This is a Rectangle\n";
    }
};

class triangle : public shape {
public:
    triangle(int w, int h) : shape(w, h) {}

    void calculate_area() override {
        cout << "Area of Triangle = " << 0.5 * width * height << endl;
    }

    void display() override {
        cout << "This is a Triangle\n";
    }
};

class circle : public shape {
    int rad;
public:
    circle(int r) : shape(0,0), rad(r) {}

    void calculate_area() override {
        cout << "Area of Circle = " << 3.141592654 * rad * rad << endl;
    }

    void display() override {
        cout << "This is a Circle\n";
    }
};

int main() {
    rectangle r(6, 7);
    shape* ptr = &r;
    ptr->display();
    ptr->calculate_area();

    triangle t(4, 5);
    ptr = &t;
    ptr->display();
    ptr->calculate_area();

    circle c(7);
    ptr = &c;
    ptr->display();
    ptr->calculate_area();

    return 0;
}



==========================================================================================================================================================================================

3.

#include <iostream>
#include <cmath>
using namespace std;

// Overloaded functions

// 1. Right-angled triangle: base & height
float area(float base, float height) {
    return 0.5f * base * height;
}

// 2. Equilateral triangle: only side needed
float area(float side) {
    return (sqrt(3) / 4) * side * side;
}

// 3. Isosceles triangle: two equal sides (a) and base (b)
float area(float equalSide, float base, bool isIsosceles) {
    // height = sqrt(a^2 - (b/2)^2)
    float height = sqrt(equalSide * equalSide - (base * base) / 4.0f);
    return 0.5f * base * height;
}

int main() {
    float b, h, s, a;

    cout << "Enter base & height for right-angled triangle: ";
    cin >> b >> h;
    cout << "Area = " << area(b, h) << endl;

    cout << "Enter side for equilateral triangle: ";
    cin >> s;
    cout << "Area = " << area(s) << endl;

    cout << "Enter equal side & base for isosceles triangle: ";
    cin >> a >> b;
    cout << "Area = " << area(a, b, true) << endl;

    return 0;
}

==========================================================================================================================================================================================
4.

#include <iostream>
#include <string>
using namespace std;

// Abstract base class
class Student {
protected:
    string name;
    int rollNo;

public:
    // Constructor
    Student(string n, int r) : name(n), rollNo(r) {}

    // Pure virtual function → makes this class abstract
    virtual void showDetails() = 0;

    // Virtual destructor (important for proper cleanup)
    virtual ~Student() {}
};

// Derived class: Engineering
class Engineering : public Student {
    string branch;
public:
    Engineering(string n, int r, string b)
        : Student(n, r), branch(b) {}

    void showDetails() override {
        cout << "Engineering Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nBranch: " << branch << "\n\n";
    }
};

// Derived class: Medicine
class Medicine : public Student {
    string specialization;
public:
    Medicine(string n, int r, string s)
        : Student(n, r), specialization(s) {}

    void showDetails() override {
        cout << "Medicine Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nSpecialization: " << specialization << "\n\n";
    }
};

// Derived class: Science
class Science : public Student {
    string major;
public:
    Science(string n, int r, string m)
        : Student(n, r), major(m) {}

    void showDetails() override {
        cout << "Science Student\n";
        cout << "Name: " << name << "\nRoll No: " << rollNo
             << "\nMajor: " << major << "\n\n";
    }
};

// Main function
int main() {
    // Create objects of derived classes
    Engineering e1("Alice", 101, "Computer Engineering");
    Medicine m1("Bob", 102, "Cardiology");
    Science s1("Charlie", 103, "Physics");

    // Array of base class pointers
    Student* students[3];

    // Assign derived objects to base class pointers
    students[0] = &e1;
    students[1] = &m1;
    students[2] = &s1;

    // Process them using polymorphism
    for (int i = 0; i < 3; ++i) {
        students[i]->showDetails();
    }

    return 0;
}


===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
                                                                                                 ASSIGNMENT 7
===============================================================================================================================================================================================================
===============================================================================================================================================================================================================
1.

#include <iostream>
using namespace std;

class Time{
    protected:
    int h,m,s;
     public:
    Time(){
        h=0;
        m=0;
        s=0;
    }
    Time(int hour,int min, int sec){
        h=hour;
        m=min;
        s=sec;
    }
   
    void show(){
        cout<<h<<" hours "<<m<<" minutes "<<s<<" seconds ";
    }
    Time operator+(Time t){
        Time res;
        res.h=t.h+h;
        res.m=t.m+m;
        res.s=t.s+s;
        return res;
    }
    
};
int main(){
    Time t1(5,15,34),t2(9,53,58),t3;
    t3=t1+t2;
    t3.show();
    return 0;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.

#include <iostream>
#include <string>
using namespace std;

class STRING{
    protected:
    string s; 
     public:
    STRING(){
        s="";
    }
    STRING(string str){
        s=str;
    }
   
    void show(){
        cout<<s<<endl;
    }
    STRING operator+(STRING t){
        STRING res;
        res=s+t.s;
       return res;
    }
    bool operator==(STRING t){
        if(s==t.s)
        return true;
        else 
        return false;
    }
    
};
int main(){
    STRING s1("roop"),s2("neet"),s3("roop"),s4;
    s4=s1+s2;
    s4.show();
    cout<<(s1==s2)<<endl;
    cout<<(s1==s3)<<endl;
    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.
#include <iostream>
using namespace std;

class matrix {
protected:
    int rows, cols;
    int mat[10][10];

public:
    matrix(int r = 0, int c = 0) {
        rows = r;
        cols = c;
    }

    void input() {
        cout << "Enter elements:" << endl;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cin >> mat[i][j];
            }
        }
    }

    void display() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cout << mat[i][j] << " ";
            }
            cout << endl;
        }
    }

    friend matrix operator*(const matrix &m1, const matrix &m2);
};

matrix operator*(const matrix &m1, const matrix &m2) {
    // Check if multiplication is possible
    if (m1.cols != m2.rows) {
        cout << "Matrix multiplication not possible!" << endl;
        return matrix();
    }

    matrix res(m1.rows, m2.cols);

    for (int i = 0; i < m1.rows; i++) {
        for (int j = 0; j < m2.cols; j++) {
            res.mat[i][j] = 0;
            for (int k = 0; k < m1.cols; k++) {
                res.mat[i][j] += m1.mat[i][k] * m2.mat[k][j];
            }
        }
    }

    return res;
}

int main() {
    matrix m1(3, 3), m2(3, 3);

    cout << "Enter matrix 1:" << endl;
    m1.input();
    m1.display();

    cout << "Enter matrix 2:" << endl;
    m2.input();
    m2.display();

    matrix m3 = m1 * m2;

    cout << "Result matrix:" << endl;
    m3.display();

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4.
#include <iostream>
#include <stdexcept>
using namespace std;

class SafeArray {
private:
    int size;
    int *arr;

public:
    SafeArray(int s) {
        size = s;
        arr = new int[size];
    }

    // Overloaded [] operator with bound checking
    int& operator[](int index) {
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds!");
        }
        return arr[index];
    }

    ~SafeArray() {
        delete[] arr;
    }
};

int main() {
    SafeArray A(5);

    try {
        A[0] = 10;
        A[1] = 20;
        cout << A[0] << endl;
        cout << A[4] << endl;

        // This will cause runtime error
        cout << A[10] << endl;
    }
    catch (const exception &e) {
        cout << "Error: " << e.what() << endl;
    }

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5.
#include <iostream>
using namespace std;

class Fun {
public:

    // () with no arguments
    void operator()() {
        cout << "Called with 0 arguments\n";
    }

    // () with one argument
    void operator()(int a) {
        cout << "Called with 1 argument: " << a << endl;
    }

    // () with two arguments
    void operator()(int a, int b) {
        cout << "Called with 2 arguments: " << a << ", " << b << endl;
    }

    // () with three arguments
    void operator()(int a, int b, int c) {
        cout << "Called with 3 arguments: " 
             << a << ", " << b << ", " << c << endl;
    }
};

int main() {
    Fun obj;

    obj();          // 0 arguments
    obj(10);        // 1 argument
    obj(10, 20);    // 2 arguments
    obj(1, 2, 3);   // 3 arguments

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6.
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Friend functions for input/output operator overloading
    friend istream& operator>>(istream &in, Student &s);
    friend ostream& operator<<(ostream &out, const Student &s);
};

// Overload >> (input)
istream& operator>>(istream &in, Student &s) {
    cout << "Enter name: ";
    in >> s.name;

    cout << "Enter age: ";
    in >> s.age;

    return in;
}

// Overload << (output)
ostream& operator<<(ostream &out, const Student &s) {
    out << "Name: " << s.name << ", Age: " << s.age;
    return out;
}

int main() {
    Student s1;

    // Using overloaded >>
    cin >> s1;

    // Using overloaded <<
    cout << s1 << endl;

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7. 

#include <iostream>
using namespace std;

class test{
    float value;
    public:
    test(float x){
        value=x;
    }
    void display(){
        cout<<"Value is "<<value<<endl;
    }
};
int main() {
    float a=8.6;
    test obj=a;
    obj.display();
    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8.

#include <iostream>
using namespace std;

class test{
    float value;
    public:
    test(float x){
        value=x;
    }
    void display(){
        cout<<"Value is "<<value<<endl;
    }
    operator float(){
        return value;
    }
};
int main() {
    test t1(45.4);
    float x;
    x=t1;
    cout<<"Float value = "<<x<<endl;
    return 0;
}


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9.

#include <iostream>
#include <cmath>
using namespace std;

class Cartesian {
private:
    float x, y;

public:
    Cartesian(float a = 0, float b = 0) {
        x = a;
        y = b;
    }

    void show() {
        cout << "Cartesian Coordinates: (" << x << ", " << y << ")" << endl;
    }
};

class Polar {
private:
    float r, theta;   // theta in radians

public:
    Polar(float radius = 0, float angle = 0) {
        r = radius;
        theta = angle;
    }

    // UDT (Polar) → UDT (Cartesian) conversion
    operator Cartesian() {
        float x = r * cos(theta); 
        float y = r * sin(theta);
        return Cartesian(x, y);
    }
};

int main() {
    Polar p(10, 5);        // r = 10, θ = 5 radians
    Cartesian c = p;       // calls conversion operator
    c.show();

    return 0;
}
