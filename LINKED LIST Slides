1 .  MERGING TWO LISTS


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class node {
public:
    int data;
    node* next;
    node(int value) {
        data = value;
        next = nullptr;
    }
};

class list {
public:
    node* head = nullptr; // make public so merge can access

    void insert(int val) {
        node* newnode = new node(val);
        if (head == nullptr) {
            head = newnode;
        }
        else {
            node* temp = head;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = newnode;
        }
    }

    void display() {
        node* temp = head;
        while (temp != nullptr) {
            cout << temp->data << "  ";
            temp = temp->next;
        }
        cout << endl;
    }
};

/// ---------- 1. Brute Force ----------
node* mergeBruteForce(node* l1, node* l2) {
    vector<int> values;

    while (l1) {
        values.push_back(l1->data);
        l1 = l1->next;
    }
    while (l2) {
        values.push_back(l2->data);
        l2 = l2->next;
    }

    sort(values.begin(), values.end());

    if (values.empty()) return nullptr;

    node* head = new node(values[0]);
    node* temp = head;

    for (size_t i = 1; i < values.size(); i++) {
        temp->next = new node(values[i]);
        temp = temp->next;
    }
    return head;
}

/// ---------- 2. Iterative Merge (new nodes) ----------
node* mergeIterative(node* l1, node* l2) {
    node dummy(0);
    node* tail = &dummy;

    while (l1 && l2) {
        if (l1->data <= l2->data) {
            tail->next = new node(l1->data);
            l1 = l1->next;
        } else {
            tail->next = new node(l2->data);
            l2 = l2->next;
        }
        tail = tail->next;
    }

    while (l1) {
        tail->next = new node(l1->data);
        l1 = l1->next;
        tail = tail->next;
    }
    while (l2) {
        tail->next = new node(l2->data);
        l2 = l2->next;
        tail = tail->next;
    }

    return dummy.next;
}

/// ---------- 3. Recursive Merge ----------
node* mergeRecursive(node* l1, node* l2) {
    if (!l1) return l2;
    if (!l2) return l1;

    node* result = nullptr;

    if (l1->data <= l2->data) {
        result = l1;
        result->next = mergeRecursive(l1->next, l2);
    } else {
        result = l2;
        result->next = mergeRecursive(l1, l2->next);
    }
    return result;
}

/// ---------- 4. In-place Merge ----------
node* mergeInPlace(node* l1, node* l2) {
    if (!l1) return l2;
    if (!l2) return l1;

    node* head = nullptr;
    if (l1->data <= l2->data) {
        head = l1;
        l1 = l1->next;
    } else {
        head = l2;
        l2 = l2->next;
    }

    node* tail = head;

    while (l1 && l2) {
        if (l1->data <= l2->data) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }

    if (l1) tail->next = l1;
    if (l2) tail->next = l2;

    return head;
}

//// ---------------- Main ----------------
int main() {
    list l1, l2;
    l1.insert(3);
    l1.insert(7);
    l1.insert(10);

    l2.insert(1);
    l2.insert(2);
    l2.insert(5);
    l2.insert(8);
    l2.insert(10);

    cout << "List 1: "; l1.display();
    cout << "List 2: "; l2.display();

    // Brute Force
    node* bf = mergeBruteForce(l1.head, l2.head);
    cout << "Brute Force: ";
    for (node* t = bf; t; t = t->next) cout << t->data << " ";
    cout << endl;

    // Iterative Merge
    node* it = mergeIterative(l1.head, l2.head);
    cout << "Iterative Merge: ";
    for (node* t = it; t; t = t->next) cout << t->data << " ";
    cout << endl;

    // Recursive Merge
    node* rec = mergeRecursive(l1.head, l2.head);
    cout << "Recursive Merge: ";
    for (node* t = rec; t; t = t->next) cout << t->data << " ";
    cout << endl;

    // In-place Merge
    node* inpl = mergeInPlace(l1.head, l2.head);
    cout << "In-place Merge: ";
    for (node* t = inpl; t; t = t->next) cout << t->data << " ";
    cout << endl;

    return 0;
}

==============================================================================================================================

void bubbleSort() {
    if (!head) return;

    bool swapped = true;
    while (swapped) {
        swapped = false;
        Node* temp = head;

        while (temp->next) {
            if (temp->data > temp->next->data) {
                // manual swap
                int x = temp->data;
                temp->data = temp->next->data;
                temp->next->data = x;

                swapped = true;
            }
            temp = temp->next;
        }
    }
}
===================================================================================================================
bool isPresent(Node* head, int val) {
    Node* temp = head;
    while (temp) {
        if (temp->data == val) return true;
        temp = temp->next;
    }
    return false;
}

static LinkedList Union(LinkedList& l1, LinkedList& l2) {
    LinkedList result;
    Node* t1 = l1.head;

    // Copy all elements of l1
    while (t1) {
        if (!isPresent(result.head, t1->data))
            result.insert(t1->data);
        t1 = t1->next;
    }

    // Copy unique elements of l2
    Node* t2 = l2.head;
    while (t2) {
        if (!isPresent(result.head, t2->data))
            result.insert(t2->data);
        t2 = t2->next;
    }

    return result;
}


static LinkedList Intersection(LinkedList& l1, LinkedList& l2) {
    LinkedList result;
    Node* t1 = l1.head;

    while (t1) {
        if (isPresent(l2.head, t1->data) && !isPresent(result.head, t1->data)) {
            result.insert(t1->data);
        }
        t1 = t1->next;
    }

    return result;
}
------------------------------------------------------------------------------------------------------

#include <iostream>
using namespace std;

class node {
public:
    int data;
    node* next;
    node(int val = 0) {
        data = val;
        next = nullptr;
    }
};

class linklist {
    node* head = nullptr;
    node* temp = nullptr;

public:
    void insert_at_begin(int value) {
        node* newnode = new node(value);
        if (head == nullptr) {
            head = temp = newnode;
        } else {
            newnode->next = head;
            head = newnode;
        }
    }

    void del_at_begin() {
        if (head == nullptr) {
            cout << "List is already empty" << endl;
            return;
        }
        node* delnode = head;
        head = head->next;
        if (head == nullptr) temp = nullptr; // reset tail
        delete delnode;
    }

    void insert_at_end(int value) {
        node* newnode = new node(value);
        if (head == nullptr) {
            head = temp = newnode;
        } else {
            temp->next = newnode;
            temp = newnode;
        }
    }

    void del_at_end() {
        if (head == nullptr) {
            cout << "Linked list is empty.\n";
            return;
        }
        if (head->next == nullptr) {
            delete head;
            head = temp = nullptr;
            return;
        }
        node* prev = head;
        node* curr = head->next;
        while (curr->next != nullptr) {
            prev = curr;
            curr = curr->next;
        }
        prev->next = nullptr;
        delete curr;
        temp = prev; // update tail
    }

    void display() {
        node* t1 = head;
        while (t1) {
            cout << t1->data << "  ";
            t1 = t1->next;
        }
        cout << endl;
    }
    node* reverseKGroup(node* head, int k) {
    if (!head || k == 1) return head;

    // Step 1: check if there are at least k nodes
    node* t = head;
    int count = 0;
    while (t && count < k) {
        t = t->next;
        count++;
    }
    if (count < k) return head;  // fewer than k nodes â†’ don't reverse

    // Step 2: reverse first k nodes
    node* prev = nullptr;
    node* curr = head;
    node* next = nullptr;
    count = 0;
    while (curr && count < k) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
        count++;
    }

    // Step 3: connect with recursion
    if (next != nullptr) {
        head->next = reverseKGroup(next, k);
    }

    // prev is new head of reversed group
    return prev;
}

void revk(int k) {
    head = reverseKGroup(head, k);

    // update tail (temp)
    temp = head;
    if (temp) {
        while (temp->next) temp = temp->next;
    }
}

    node* reverse(node* head){
        if(head==nullptr || head->next==nullptr){
            return head;
        }
        node *rev= reverse(head->next);
        head->next->next= head;
        head->next=nullptr;
        return rev;
    }
    void reverse_list(){
        head=reverse(head);
        temp = head;
        if (temp) {
            while (temp->next) temp = temp->next;
        }
    }
};

int main() {
    linklist l;
    l.insert_at_begin(5);
    l.insert_at_begin(2);
    l.insert_at_begin(1);
    l.insert_at_begin(6);
    l.insert_at_begin(8);
    l.insert_at_begin(4);
    l.display();
    //l.reverse_list();
    l.revk(2);
    l.display();         
    return 0;
}
