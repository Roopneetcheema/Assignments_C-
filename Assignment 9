A graph G is defined as a pair (V, E) where V is a set of nodes/vertices and E is a set of edges connecting
pairs of vertices. Graphs may be directed or undirected and may have weighted or unweighted edges.
They can be represented using an adjacency matrix, adjacency list, or edge list.
Write a program to implement the following graph algorithms:

========================================================================BASIC STRUCTURE======================================================================================

#include <iostream>
#include <vector>
using namespace std;

class Graph {
private:
    int no_of_vertices;
    bool isDirected;
    vector<vector<int>> adjmat;  

public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
    }

    void addVertex() {
        no_of_vertices++;

        adjmat.push_back(vector<int>(no_of_vertices, 0));

        for (int i = 0; i < no_of_vertices - 1; i++) {
            adjmat[i].push_back(0);
        }

        cout << "Vertex " << no_of_vertices - 1 << " added successfully!\n";
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }

        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;

        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(4, false); 
    g.addEdge(1,2);
    g.addEdge(3,2);
    g.display();
    g.addVertex();
    g.addEdge(4,1);
    g.display();

    return 0;
}
================================================================================================================================================================
1. Breadth First Search (BFS)
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;

  class Graph {
  private:
    int no_of_vertices;
    bool isDirected;
    vector<vector<int>> adjmat; 

  public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }
        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;
        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }
    }
    void BFS(int start) {
        if (start < 0 || start >= no_of_vertices) {
            cout << "Invalid starting vertex!\n";
            return;
        }

        vector<bool> visited(no_of_vertices, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        cout << "\nBFS traversal starting from vertex " << start << ": ";

        while (!q.empty()) {
            int current = q.front();
            q.pop();
            cout << current << " ";

            for (int j = 0; j < no_of_vertices; j++) {
                if (adjmat[current][j] == 1 && !visited[j]) {
                    visited[j] = true;
                    q.push(j);
                }
            }
        }
        cout << endl;
    }
};

int main() {
    Graph g(5, false); 
    g.addEdge(0,1);
    g.addEdge(1,2);
    g.addEdge(2,3);
    g.addEdge(1,3);
    g.addEdge(1,4);
    g.display();
    g.BFS(0);

    return 0;
}

=============================================================================================================================================================

2. Depth First Search (DFS)

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Graph {
private:
    int no_of_vertices;
    bool isDirected;
    vector<bool> visited;
    vector<vector<int>> adjmat; 
    

public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
        visited.resize(no_of_vertices, false); 
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }
        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;
        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }
    }
    void dfs(int start) {
        cout<<start<<" ";
        visited[start]=1;
        for(int j=0;j<no_of_vertices;j++){
            if(adjmat[start][j]==1 && !visited[j]){
                dfs(j);
            }
        }
        
    }
    void DFS(int start) { 
        cout<<endl<<"DFS of given graph is "<<endl;
        dfs(start);
    }
};

int main() {
    Graph g(7, false); 
    g.addEdge(0,1);
    g.addEdge(0,2);
    g.addEdge(0,3);
    g.addEdge(1,0);
    g.addEdge(2,4);
    g.addEdge(3,0);
    g.addEdge(3,2);
    g.addEdge(4,3);
    g.addEdge(4,5);
    g.addEdge(4,6);
    g.display();
    g.DFS(4);

    return 0;
}

=============================================================================================================================================================
3. Minimum Spanning Tree (Kruskal and Prim)
4. Dijkstra's Shortest Path Algorithm









