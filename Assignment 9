A graph G is defined as a pair (V, E) where V is a set of nodes/vertices and E is a set of edges connecting
pairs of vertices. Graphs may be directed or undirected and may have weighted or unweighted edges.
They can be represented using an adjacency matrix, adjacency list, or edge list.
Write a program to implement the following graph algorithms:

========================================================================BASIC STRUCTURE======================================================================================

#include <iostream>
#include <vector>
using namespace std;

struct node {
    int data;
    node* next;
    node(int v = 0) {
        data = v;
        next = nullptr;
    }
};

class Graph {
private:
    int no_of_vertices;
    bool isDirected;
    vector<vector<int>> adjmat;
    vector<node*> adjlist;

public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
        adjlist.resize(no_of_vertices, nullptr);
    }

    void addVertex() {
        no_of_vertices++;

        adjmat.push_back(vector<int>(no_of_vertices, 0));
        for (int i = 0; i < no_of_vertices - 1; i++) {
            adjmat[i].push_back(0);
        }

        adjlist.push_back(nullptr);

        cout << "Vertex " << no_of_vertices - 1 << " added successfully!\n";
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }

        // Update adjacency matrix
        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;

        // Update adjacency list
        node* newNode = new node(v);
        newNode->next = adjlist[u];
        adjlist[u] = newNode;

        if (!isDirected) {
            node* newNode2 = new node(u);
            newNode2->next = adjlist[v];
            adjlist[v] = newNode2;
        }

        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }

        cout << "\nAdjacency List:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            cout << i << " -> ";
            node* temp = adjlist[i];
            while (temp != nullptr) {
                cout << temp->data << " ";
                temp = temp->next;
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(4, false);   // undirected graph

    g.addEdge(1,2);
    g.addEdge(3,2);

    g.display();

    g.addVertex();
    g.addEdge(4,1);

    g.display();

    return 0;
}

================================================================================================================================================================
1. Breadth First Search (BFS)
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;

  class Graph {
  private:
    int no_of_vertices;
    bool isDirected;
    vector<vector<int>> adjmat; 

  public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }
        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;
        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }
    }
    void bfs(int s) {
        vector<string> color(no_of_vertices, "WHITE");
        vector<int> dist(no_of_vertices, INT_MAX);
        vector<int> parent(no_of_vertices, -1);

        queue<int> Q;

        color[s] = "GRAY";
        dist[s] = 0;
        parent[s] = -1;

        Q.push(s);

        cout << "\nBFS traversal starting from vertex " << s << ": ";

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            cout << u << " ";

            node* temp = adjlist[u];
            while (temp != nullptr) {
                int v = temp->data;
                if (color[v] == "WHITE") {
                    color[v] = "GRAY";
                    dist[v] = dist[u] + 1;
                    parent[v] = u;
                    Q.push(v);
                }
                temp = temp->next;
            }
            color[u] = "BLACK";
        }
        cout << endl;
    }
};

    void BFS(int start) {
        if (start < 0 || start >= no_of_vertices) {
            cout << "Invalid starting vertex!\n";
            return;
        }

        vector<bool> visited(no_of_vertices, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        cout << "\nBFS traversal starting from vertex " << start << ": ";

        while (!q.empty()) {
            int current = q.front();
            q.pop();
            cout << current << " ";

            for (int j = 0; j < no_of_vertices; j++) {
                if (adjmat[current][j] == 1 && !visited[j]) {
                    visited[j] = true;
                    q.push(j);
                }
            }
        }
        cout << endl;
    }
};

int main() {
    Graph g(5, false); 
    g.addEdge(0,1);
    g.addEdge(1,2);
    g.addEdge(2,3);
    g.addEdge(1,3);
    g.addEdge(1,4);
    g.display();
    g.BFS(0);

    return 0;
}

=============================================================================================================================================================

2. Depth First Search (DFS)

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Graph {
private:
    int no_of_vertices;
    bool isDirected;
    vector<bool> visited;
    vector<vector<int>> adjmat; 
    

public:
    Graph(int vertices, bool directed = false) {
        no_of_vertices = vertices;
        isDirected = directed;
        adjmat.resize(no_of_vertices, vector<int>(no_of_vertices, 0));
        visited.resize(no_of_vertices, false); 
    }

    void addEdge(int u, int v) {
        if (u < 0 || v < 0 || u >= no_of_vertices || v >= no_of_vertices) {
            cout << "Invalid vertex number!\n";
            return;
        }
        adjmat[u][v] = 1;
        if (!isDirected)
            adjmat[v][u] = 1;
        cout << "Edge added between " << u << " and " << v << endl;
    }

    void display() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < no_of_vertices; i++) {
            for (int j = 0; j < no_of_vertices; j++) {
                cout << adjmat[i][j] << " ";
            }
            cout << endl;
        }
    }
    void dfs(int start) {
        cout<<start<<" ";
        visited[start]=1;
        for(int j=0;j<no_of_vertices;j++){
            if(adjmat[start][j]==1 && !visited[j]){
                dfs(j);
            }
        }
        
    }
    void DFS(int start) { 
        cout<<endl<<"DFS of given graph is "<<endl;
        dfs(start);
    }

void DFS_slide() {
        vector<string> color(no_of_vertices, "WHITE");
        vector<int> parent(no_of_vertices, -1);
        vector<int> d(no_of_vertices, 0);
        vector<int> f(no_of_vertices, 0);
        int time = 0;

        cout << "\nDFS Traversal: ";
        for (int u = 0; u < no_of_vertices; u++) {
            if (color[u] == "WHITE")
                DFS_Visit(u, color, parent, d, f, time);
        }
        cout << endl;
    }

    void DFS_Visit(int u, vector<string> &color, vector<int> &parent,
                   vector<int> &d, vector<int> &f, int &time) {

        time = time + 1;
        d[u] = time;
        color[u] = "GRAY";

        cout << u << " ";

        node* temp = adjlist[u];
        while (temp != nullptr) {
            int v = temp->data;
            if (color[v] == "WHITE") {
                parent[v] = u;
                DFS_Visit(v, color, parent, d, f, time);
            }
            temp = temp->next;
        }

        color[u] = "BLACK";
        time = time + 1;
        f[u] = time;
    }
};

int main() {
    Graph g(7, false); 
    g.addEdge(0,1);
    g.addEdge(0,2);
    g.addEdge(0,3);
    g.addEdge(1,0);
    g.addEdge(2,4);
    g.addEdge(3,0);
    g.addEdge(3,2);
    g.addEdge(4,3);
    g.addEdge(4,5);
    g.addEdge(4,6);
    g.display();
    g.DFS(4);

    return 0;
}

=============================================================================================================================================================
3. Minimum Spanning Tree ( Prim)

#include <iostream>
#include <vector>
using namespace std;

#define INF 999999

void primMST(vector<vector<int>> &graph, int V) {
    vector<int> key(V, INF);  
    vector<bool> inMST(V, false); 
    vector<int> parent(V, -1);   

    key[0] = 0;  // Start from vertex 0

    for (int count = 0; count < V - 1; count++) {
        // Pick the minimum key value from vertices not yet in MST
        int minKey = INF, u;
        for (int v = 0; v < V; v++) {
            if (!inMST[v] && key[v] < minKey) {
                minKey = key[v];
                u = v;
            }
        }

        inMST[u] = true;  
        for (int v = 0; v < V; v++) {
            // graph[u][v] is weight of edge u-v
            if (graph[u][v] && !inMST[v] && graph[u][v] < key[v]) {
                key[v] = graph[u][v];
                parent[v] = u;
            }
        }
    }

    // Print MST result
    cout << "\nEdges in Minimum Spanning Tree (Prim's):\n";
    for (int i = 1; i < V; i++) {
        cout << parent[i] << " -- " << i << "  Weight: " << graph[i][parent[i]] << endl;
    }
}
int main() {
    int V = 5;
    vector<vector<int>> graph = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    primMST(graph, V);
    return 0;
}

===============================================================================================================================================================

4. Dijkstra's Shortest Path Algorithm

#include <iostream>
#include <vector>
using namespace std;

#define INF 999999

void dijkstra(vector<vector<int>> &graph, int V, int src) {
    vector<int> dist(V, INF);
    vector<bool> visited(V, false);
    vector<int> parent(V, -1);

    dist[src] = 0;

    // Dijkstra runs V-1 times
    for (int count = 0; count < V - 1; count++) {

        // Step 1: Pick minimum distance node NOT visited
        int mindis = INF;
        int min_node = -1;

        for (int j = 0; j < V; j++) {
            if (!visited[j] && dist[j] < mindis) {
                mindis = dist[j];
                min_node = j;
            }
        }

        visited[min_node] = true;

        // Step 2: Relax edges
        for (int v = 0; v < V; v++) {
            if (graph[min_node][v] != 0 && !visited[v] &&
                dist[min_node] + graph[min_node][v] < dist[v]) {

                dist[v] = dist[min_node] + graph[min_node][v];
                parent[v] = min_node;
            }
        }
    }

    // Print results
    cout << "\nShortest distances from source " << src << ":\n";
    for (int i = 0; i < V; i++) {
        cout << "Vertex " << i << " : Distance = " << dist[i];
        if (parent[i] != -1) cout << " Parent = " << parent[i];
        cout << endl;
    }
}

int main() {
    int V = 5;
    vector<vector<int>> graph = {
        {0, 10, 0, 30, 100},
        {10, 0, 50, 0, 0},
        {0, 50, 0, 20, 10},
        {30, 0, 20, 0, 60},
        {100, 0, 10, 60, 0}
    };

    dijkstra(graph, V, 0);
    return 0;
}


============================================================================================================================================================

5. Floyd–Warshall (All-Pairs Shortest Path)
#include <bits/stdc++.h>
using namespace std;

const long long INF = 1e15;

int main() {
    int n = 4;
    vector<vector<long long>> dist(n, vector<long long>(n, INF));

    // distance to self = 0
    for (int i = 0; i < n; i++) dist[i][i] = 0;

    auto addEdge = [&](int u, int v, long long w) {
        dist[u][v] = min(dist[u][v], w); // handle multi edges
        dist[v][u] = min(dist[v][u], w); // if undirected
    };

    addEdge(0, 1, 3);
    addEdge(0, 2, 5);
    addEdge(1, 2, 1);
    addEdge(1, 3, 4);
    addEdge(2, 3, 2);

    // Floyd–Warshall
    for (int k = 0; k < n; k++) {          // intermediate
        for (int i = 0; i < n; i++) {      // source
            for (int j = 0; j < n; j++) {  // destination
                if (dist[i][k] < INF && dist[k][j] < INF)
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    cout << "All-pairs shortest distances:\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] >= INF/2) cout << "INF ";
            else cout << dist[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}



=================================================================================================================================================

6. Disjoint Sets (Union–Find / DSU)

struct DSU {
    vector<int> parent, size;

    DSU(int n) {
        parent.resize(n);
        size.assign(n, 1);

        for (int i = 0; i < n; i++)
            parent[i] = i;   // each node is its own leader
    }

    int find(int x) {
        if (x == parent[x])
            return x;
        return parent[x] = find(parent[x]); 
        // path compression: directly connect to leader
    }

    void unite(int a, int b) {
        a = find(a);
        b = find(b);

        if (a != b) {
            // union by size
            if (size[a] < size[b])
                swap(a, b);

            parent[b] = a;
            size[a] += size[b];
        }
    }
};





